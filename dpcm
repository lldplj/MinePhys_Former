import torch
import torch.nn as nn


class DualPathChannelModeling(nn.Module):
    def __init__(self, d_model, dropout=0.1):
        super(DualPathChannelModeling, self).__init__()
        self.local_path = nn.Sequential(
            nn.Conv1d(d_model, d_model, kernel_size=3, padding=1, groups=d_model),
            nn.BatchNorm1d(d_model),
            nn.SiLU()
        )
        self.global_path = nn.Sequential(
            nn.AdaptiveAvgPool1d(1),  # Squeeze time -> [B, C, 1]
            nn.Conv1d(d_model, d_model // 4, kernel_size=1),
            nn.ReLU(),
            nn.Conv1d(d_model // 4, d_model, kernel_size=1),
            nn.Sigmoid()  # Excite
        )
        self.out_proj = nn.Linear(d_model * 2, d_model)
        self.norm = nn.LayerNorm(d_model)
        self.dropout = nn.Dropout(dropout)

    def forward(self, x):
        x_in = x.transpose(1, 2)
        local_feat = self.local_path(x_in)
        attn_weights = self.global_path(x_in)
        global_feat = x_in * attn_weights
        concat_feat = torch.cat([local_feat, global_feat], dim=1)
        concat_feat = concat_feat.transpose(1, 2)
        out = self.out_proj(concat_feat)
        return self.norm(x + self.dropout(out))
